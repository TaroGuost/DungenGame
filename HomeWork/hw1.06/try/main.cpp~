#include <iostream>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <endian.h>
#include <limits.h>
#include <math.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/time.h>
#include <ncurses.h>

#include "map.h"
#include "RLfile.h"
#include "pQueue.h"

using namespace std;




bool Move( Monster *M , int mc ,  Monster *Ori ,  point base[21][80], int px , int py, bool check);
bool MoveSix( Monster *M, int px , int py ,  point base[21][80] , int mc , bool check ,  Monster *Ori);
bool Moverand( Monster *M , point base[21][80] , int mc , bool check , int px ,int py , Monster *Ori);


void Minsert(Node** head , int index , Monster *Monsters)
{
  Node* temp = (*head);

  Node* New = newNode(index);

  if(((Monsters+((*head)->index))->speed) > (Monsters+index)->speed)
    {
      New->next = *head;
      (*head) = New;	
    }
  else
    {
      while(temp->next !=NULL && (Monsters+(temp->next->index))->speed <
	    (Monsters+New->index)->speed)
	{
	  temp = temp->next;
	}

      New->next = temp->next;
      temp->next = New;
    }
}


int calculateindex(int x , int y)
{
  return (80*x)+y; 
}

void printPath(int dis[1680] ,Node **head ,  point *source)
{
  int i,j;

  for(i = 0 ; i < 21 ;i++)
    {
      for(j = 0 ; j < 80 ; j++)
	{
	  if(source->x ==i && source->y==j)
	    {
	      printf("%c" , '@');
	    }
	  else if(dis[calculateindex(i,j)] !=-1)
	    {
	      int n= dis[calculateindex(i,j)]%10;
	      printf("%d", n);
	    }
	  else
	    {
	      printf("%c" , ' ');
	    }
	}

      printf("\n");
    }
}


int getLength(int  p)
{
  if(p == 255)
    {
      return 3;
    }
  else if(p == 0)
    {
      return 1;
    }
  else
    {
      return 1 + (p/85);
    }


}

void FindShortestPath( point base[21][80],  point *source, int dis[1680])
{
  int i,j;
  int movex[8] = {-80,-80,-80,0,0,80,80,80};
  int movey[8] = {-1,0,1,-1,1,-1,0,1};
  int alt;
  Node* pq = newNode(calculateindex(source->x,source->y));
  dis[calculateindex(source->x, source->y)] = 0;

  for(i = 0 ; i < 21 ; i++)
    {
      for(j = 0 ; j < 80 ; j ++)
	{
	  if(base[i][j].value =='.' || base[i][j].value == '#' )
	    {
	      dis[calculateindex(i,j)] = INT_MAX;
	      insert(&pq,calculateindex(i,j),dis);
	    }
	  else if(base[i][j].value =='@')
	    {
	      dis[calculateindex(i,j)] = 0;
	    }
	  else
	    {
	      dis[calculateindex(i,j)] = -1;
	    }
	}
    }
  //	printPath(dis , &pq);

  while(!isEmpty(&pq))
    {

      int u = pop(&pq);

      for(i = 0 ; i < 8 ; i ++)
	{
	  alt =0;
	  int v =u+movex[i]+movey[i];
	  if(v<0 || v>1680)
	    {
	      continue;
	    }

	  if(dis[v]>=0)
	    {
	      alt = dis[u]+ 1;

	      if(alt < dis[v])
		{
		  dis[v] = alt;
		  insert(&pq , v,dis);
		}

	    }	
	}	
    }

  //	printPath(dis , &pq ,source);
  free(pq);
}

void printWallPath(int dis[1680] , point *source)
{
  int i,j;

  for(i = 0 ; i < 21 ;i++)
    {
      for(j = 0 ; j < 80 ; j++)
	{
	  if(source->x == i && source->y== j)
	    {
	      printf("%c" , '@');
	    }
	  else if(dis[calculateindex(i,j)] != -1)
	    {
	      int n= dis[calculateindex(i,j)]%10;
	      printf("%d" , n );
	    }
	  else{
	    printf(" ");
	  }
	}

      printf("\n");
    }
}



void FindShortestPathWithWall( point base[21][80],  point *source , int dis[1680])
{
  int i,j;
  int movex[8] = {-80,-80,-80,0,0,80,80,80};
  int movey[8] = {-1,0,1,-1,1,-1,0,1};
  int alt;
  Node* pq = newNode(calculateindex(source->x,source->y));
  dis[calculateindex(source->x, source->y)] = 0;

  for(i = 0 ; i < 21 ; i++)
    {
      for(j = 0 ; j < 80 ; j ++)
	{


	  if(base[i][j].value != '@' && base[i][j].value != '|' && base[i][j].value != '-')
	    {
	      dis[calculateindex(i,j)] = 99999;
	      insert(&pq,calculateindex(i,j),dis);
	    }
	  else if(base[i][j].value != '@')
	    {
	      dis[calculateindex(i,j)] = -1;
	    }

	}
    }

  while(!isEmpty(&pq))
    {
      int u = pop(&pq);

      for (i = 0 ; i < 8 ; i ++)
	{
	  alt =0;

	  int v = u+movex[i]+movey[i];

	  if(v<0 || v>1680)
	    {
	      continue;
	    }

	  if(dis[v]>=0 )
	    {
	      alt = dis[u]+getLength(base[u/80][u%80].hardness);

	      if(alt < dis[v])
		{			 
		  dis[v] = alt;
		  insert(&pq , v , dis);
		}

	    }

	}

    }


  //	printWallPath(dis ,source);
  free(pq);
}


int GeneStair( point base[21][80])
{
  int i,j;
  
  for(i = 0 ; i < 21 ; i ++)
    {
      for(j = 0 ; j < 80 ; j++)
	{
	  if(base[i][j].value == '.')
	    {
	      base[i][j].value = '<';
	      return i*80+j;
	    }
	} 
    }

  return 0;
  
}

int GeneDStair( point base[21][80])
{
  int i,j;
  
  for(i = 19 ; i >= 0 ; i --)
    {
      for(j = 79 ; j >= 0 ; j--)
	{
	  if(base[i][j].value == '.')
	    {
	      base[i][j].value = '>';
	      return i*80+j;
	    }
	} 
    }

  return 0;
}


char Mtype(int a, int b , int c ,int d)
{
  long int bin , hex= 0 , i =1 , temp;
  bin = (rand()+1)%a + ((rand()+1)%b*10)+ ((rand()+1)%c*100)+ ((rand()+1)%d*1000);
  while(bin != 0)
    {
      temp = bin%10;
      hex += temp*i;
      i = i*2;
      bin = bin/10;
    }

    
  return hex;
    
    
}


int isSamePlace( Monster *Monsters , int mc , int x , int y)
{

  int i;
  for(i = 0 ; i < mc ; i ++ )
    {
      if((Monsters+i)->x == x && (Monsters+i)->y == y)
	{
	  return i;
	}
    }
  return -1;
}



void PrintMonster(WINDOW **game , Monster *ms , int mc ,  point base[21][80] , int px , int py , int stair , int Dstair)
{
  int i,j;

  for(i = 0 ; i < 21 ; i ++)
    {
      for(j = 0 ; j < 80 ; j ++)
	{
	  if(base[i][j].value == ' ' && base[i][j].hardness == 0)
	    {
	      base[i][j].value = '#';
	    }	

	  if(i == stair/80 && j == stair%80)
	    {
	       base[i][j].value ='<';	     
	    }

	   if(i == Dstair/80 && j == Dstair%80)
	    {
	       base[i][j].value ='>';	     
	    }

	  int temp = isSamePlace(ms,mc,i,j);
	  if(temp  != -1)
	    {
	      mvwprintw(*game,i,j,"%lx" , (ms+temp)->type);
	      //refresh();
	    }
	  else
	    {
	      mvwprintw(*game,i,j,"%c" , base[i][j].value);
	      //refresh();
	    }

	   if(i == px && j == py)
	  {
	   mvwprintw(*game,i,j,"%c" , '@');
	  }
  
	}
    }

}



bool IfPC( room *r ,  point base[21][80])
{
  int i,j;

  for(i = (r->x) ; i < ((r->x)+(r->rw)) ; i ++)
    {
      for(j = (r->y) ; j < ((r->y)+(r->rl)); j ++)
	{
	  if(base[i][j].value == '@')
	    {
	      return true;
	    }
	}
    }
  
  return false;
}


void GMonster( room *rooms ,  Monster *Monsters , int size ,  point base[21][80] , int mc)
{
  int MonsterCount = 0;

  while(MonsterCount < mc)
    {
      int random = (rand()%size);
      if(!IfPC(rooms+random, base))
	{
	  (Monsters+MonsterCount)->x = ((rooms+random)->x)+(rand()%(rooms+random)->rl);
	  (Monsters+MonsterCount)->y = ((rooms+random)->y)+(rand()%(rooms+random)->rw);
	  (Monsters+MonsterCount)->type = Mtype(2,2,2,2);
	  (Monsters+MonsterCount)->speed = 0;
	  (Monsters+MonsterCount)->s = (rand()%16)+5;
	  MonsterCount++;
	}
    }
  

}

bool EMove( Monster *Monsters, Monster *Ori , int mc , int px , int py , point base[21][80] , char temp)
{
  bool dead = false;
  
  switch(temp)
    {
    case 0 :
      dead = Moverand(Monsters,base, mc, false , px , py , Ori);
      break;
    case 1:
      if(Monsters->x == px || Monsters->y == py)
	dead = Move(Monsters,mc,Ori,base,px,py,false);
      else
	dead = Moverand(Monsters,base, mc, false , px , py , Ori);
      break;
    case 2:
      dead = MoveSix(Monsters,px ,py ,base , mc , false, Ori);
      break;
    case 3:
      dead = Move(Monsters,mc,Ori,base,px,py,false);
      break;
    case 4:
      dead = Moverand(Monsters,base,mc,true,px,py,Ori);
      break;
    case 5:
      if(Monsters->x == px || Monsters->y == py)
	dead = Move(Monsters,mc,Ori,base,px,py,true);
      else
	dead = Moverand(Monsters,base, mc, true , px , py , Ori);
      break;
    case 6:
      dead = MoveSix(Monsters , px , py , base ,mc ,true,Ori);
      break;
    case 7:
      dead = Move(Monsters,mc,Ori,base,px,py,true);
      break;
    }

  return dead;

}

void PrintLose( Monster *Monsters)
{
  int i, j;
  for(i = 0 ; i < 21 ; i ++)
    {
      for(j = 0 ; j < 80 ; j ++)
	{
	  if(i == 21/2 && j == 80/2)
	    {
	      printf("YOU DEAD!!!!   ");
	      printf("%lx KILLED YOU", Monsters->type);
	    }
	  else
	    {
	      printf(" ");
	    }
	}
      printf("\n");
    }


}

void addPlayer( Monster *M , int mc , int px , int py)
{
  (M+mc)->x = px;
  (M+mc)->y = py;
  (M+mc)->type = '@';
  (M+mc)->s = 10;
  (M+mc)->speed = 0;
}

void PrintList(WINDOW **list,int mc, int px ,int py, Monster *M,int n)
{
  int i;

  int x = 5;

  if(x > mc)
    x =mc;
  
  
  for(i = 0  ; i<x ; i++)
    {
      int Rx = px - (M+i+n)->x;
      int Ry = py - (M+i+n)->y;
	  
      if(Rx > 0 && Ry>0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d North and %d West ",(M+i+n)->type , Rx , Ry);
	}
      else if(Rx > 0 && Ry < 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d North and %d East ",(M+i+n)->type , Rx , (Ry*-1));
	}
      else if(Rx < 0 && Ry > 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d South and %d West ",(M+i+n)->type , Rx*-1 , Ry);
	}
      else if(Rx < 0 && Ry < 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d South and %d East ",(M+i+n)->type , Rx*-1 , Ry*-1);
	}
      else if(Rx > 0 && Ry == 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d North",(M+i+n)->type , Rx);
	}
      else if(Rx < 0 && Ry == 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d South",(M+i+n)->type , Rx*-1);
	}
      else if(Rx == 0 && Ry < 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d West ",(M+i+n)->type , Ry*-1);
	}
      else if(Rx == 0 && Ry > 0)
	{
	  mvwprintw(*list,i+1,1,"%lx, %d East ",(M+i+n)->type , Rx*-1);
	}
       
    }

   

}

void MonsterList( Monster *M, int mc , int px , int py)
{
  int i = 0;
  int n = 0;

  WINDOW *list;
  list = newwin(8,30,10,20);
  keypad(list,true);
  wborder(list,'*','*','*','*','*','*','*','*');
  while(i != 1)
    {
      PrintList(&list,mc,px,py,M,n);
      int ch = wgetch(list);
      switch(ch)
	{
	case 27:
	  i =1;
	  break;
	case 'e':
	  i =1;
	  break;
	case KEY_DOWN:
	  if(n+5<mc)
	    n++;
	  break;
	case KEY_UP:
	  if(n>0)
	    n--;
	  break;
	}
      
    }
  

  //werase(list);
  wclrtoeol(list);
  wrefresh(list);
  delwin(list);
  //endwin();
  
  
}

char PCMove( Monster *M ,  point base[21][80], WINDOW **game , char store,  Monster *Ori,int mc,int stair, int Dstair)
{

  base[M->x][M->y].value = store;
  bool check = true;

   
    
   while(check == true)
  {
       
      int ch = wgetch(*game);
      switch(ch)
	{
	case 'j':
	  if(base[(M->x)+1][M->y].hardness ==0)
	    {
	      M->x = (M->x)+1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'k':
	  if(base[(M->x)-1][M->y].hardness ==0)
	    {
	      M->x = (M->x)-1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'h':
	  if(base[M->x][(M->y)-1].hardness ==0)
	    {
	      M->y = (M->y)-1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'l':
	  if(base[M->x][(M->y)+1].hardness ==0)
	    {
	      M->y = (M->y)+1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'y':
	  if(base[(M->x)-1][(M->y)-1].hardness ==0)
	    {
	      M->y = (M->y)-1;
	      M->x = (M->x)-1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'u':
	  if(base[(M->x)-1][(M->y)+1].hardness ==0)
	    {
	      M->y = (M->y)+1;
	      M->x = (M->x)-1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'b':
	  if(base[(M->x)+1][(M->y)-1].hardness ==0)
	    {
	      M->y = (M->y)-1;
	      M->x = (M->x)+1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 'n':
	  if(base[(M->x)+1][(M->y)+1].hardness ==0)
	    {
	      M->y = (M->y)+1;
	      M->x = (M->x)+1;
	      store =  base[M->x][M->y].value;
	      base[M->x][M->y].value = '@';
	      check = false;
	    }
	  break;
	case 32:
	  check =false;
	  store =  base[M->x][M->y].value;
	  break;
	case 'Q':
	  check = false;
	  store = '!';
	  break;
	case 'm':
	  MonsterList(Ori,mc,M->x,M->y);
	  PrintMonster(game, Ori , mc,base,M->x,M->y,stair,Dstair);
	  break;
	case '<':
	  if(M->x == stair/80 && M->y == stair%80)
	    {
	      store = '^';
	      check = false;
	    }
	case '>':
	  if(M->x == Dstair/80 && M->y == Dstair%80)
	    {
	      store = '^';
	      check = false;
	    }
	  break;
	      
	}
      }

 	
  return store;

  
}


bool MonsterMove( Monster *Monsters , int mc,  point base[21][80] , int px , int py)
{
  addPlayer(Monsters , mc , px ,py);
  int i;
  bool dead = false;
  Node* mq = newNode(mc);
  bool change = false;
  bool seeP = false;
  char store = '.';
  const int stair = GeneStair(base);
  const int Dstair = GeneDStair(base);

  
  for(i = 0 ; i < mc ; i++)
    {
      Minsert(&mq , i , Monsters);
    }

 
   
  initscr();
  noecho();
  cbreak();

  WINDOW *game;
  game = newwin(24,80,0,0);

  keypad(game,true);
   
     
  while(!dead)
    {
      int  n = pop(&mq);

      switch((Monsters+n)->type)
	{
	case 0:
	  dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	  break;
	case 1:
	  if((Monsters+n)->x == px || (Monsters+n)->y == py)
	    dead = Move((Monsters+n),mc,Monsters,base,px,py,false);
	  else
	    dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	  break;
	case 2:
	  dead = MoveSix((Monsters+n),px ,py ,base , mc , false,Monsters);
	  break;
	case 3:
	  dead = Move((Monsters+n),mc,Monsters,base,px,py,false);
	  break;
	case 4:
	  dead = Moverand((Monsters+n),base,mc,true,px,py,Monsters);
	  break;
	case 5:
	  if((Monsters+n)->x == px || (Monsters+n)->y == py || change ==true)
	    {
	      dead = Move((Monsters+n),mc,Monsters,base,px,py,true);
	      change = true;
	    }
	  else
	    {
	      dead = Moverand((Monsters+n),base, mc, true , px , py , Monsters);
	    }
	  break;
	case 6:
	  dead = MoveSix((Monsters+n) , px , py , base ,mc ,true,Monsters);
	  break;
	case 7:
	  dead = Move((Monsters+n),mc,Monsters,base,px,py,true);
	  break;
	case 8:
	  dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	  break;
	case 9:
	  if(rand()%2 == 0)
	    {
	      if((Monsters+n)->x == px || (Monsters+n)->y == py || seeP ==true)
		{
		  dead = Move((Monsters+n),mc,Monsters,base,px,py,false);
		  seeP = true;
		}
	      else
		{
		  dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
		}
	    }
	  else
	    {
	      dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	    }
	  break;
	case 10:
	  if(rand()%2 ==0)
	    {
	      dead = MoveSix((Monsters+n),px ,py ,base , mc , false , Monsters);
	    }
	  else
	    {
	      dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	    }
	  break;
	case 11:
	  dead = EMove((Monsters+n),Monsters, mc , px , py,base, Mtype(1,1,2,2));
	  break;
	case 12:
	  if(rand()%2 ==0)
	    {
	      dead = Moverand((Monsters+n),base,mc,true,px,py,Monsters);
	    }
	  else
	    {
	      dead = Moverand((Monsters+n),base, mc, false , px , py , Monsters);
	    }
	  break;
	case 13:
	  dead =  EMove((Monsters+n),Monsters, mc , px , py,base, Mtype(1,2,1,2));
	  break;
	case 14:
	  dead =  EMove((Monsters+n),Monsters, mc , px , py,base , Mtype(1,2,2,1));
	  break;
	case 15:
	  dead =  EMove((Monsters+n),Monsters, mc , px , py,base, Mtype(1,2,2,2));
	  break;
	case '@':
	  usleep(250000);
	  PrintMonster(&game,Monsters, mc , base,px,py , stair , Dstair);
	  //tempprint(&game);
	  store = PCMove((Monsters+n),base,&game,store,Monsters,mc,stair,Dstair);
	  px = (Monsters+n)->x;
	  py = (Monsters+n)->y;
	  break;
	}

      if(store == '!')
	{
	  clrtoeol();
	  refresh();
	  endwin();
	  printf("\n YourQuitGame!!!D:\n");
	  break;
	}

      if(store == '^')
	{
	  clrtoeol();
	  refresh();
	  endwin();
	  return true;
	}
	 
      if(dead)
	{
	  clrtoeol();
	  refresh();
	  endwin();
	  PrintLose(Monsters+n);
	  break;  
	}

	  
      (Monsters+n)->speed += (Monsters+n)->s;
      Minsert(&mq , n , Monsters);


    }

  return false;
       
}


bool Move( Monster *M, int mc ,  Monster *Ori ,  point base[21][80],int px, int py, bool check)
{
  int movex[8] = {-80,-80,-80,0,0,80,80,80};
  int movey[8] = {-1,0,1,-1,1,-1,0,1};
  int i;
  int x = 0;
  int y = 0;
  int dis[1680];

  if(check == true)
    FindShortestPathWithWall(base , &base[px][py],dis);
  else
    FindShortestPath(base,&base[px][py],dis);
  

  int min = dis[calculateindex(M->x,M->y)];
   

   
  for(i = 0 ; i < 8 ; i ++)
    {

      int v = calculateindex(M->x,M->y) + movex[i] + movey[i];

      if( v<=0 || v>=1680)
	{
	  continue;
	}
     
      if(dis[v] != -1 )
	{
        
	  if(dis[v] < min  && isSamePlace(Ori , mc , v/80 , v%80) == -1)
	    {	
	      x = v/80;
	      y = v%80;
	      min = dis[v];
	    }

	  
	}

    }

  if(M->x == px && M->y == py)
    {
      return true;
    }
  
  if(dis[calculateindex(M->x,M->y)]- dis[calculateindex(x,y)] > 1  )
    {
      dis[calculateindex(x,y)]++;
    }
  else
    {

      if(x != 0 && y !=0)
	{
	  (M->x)= x;
	  (M->y)= y;
	  base[x][y].hardness = 0;
        }

      if(M->x == px && M->y == py)
	{
	  return true;
	}

    }
  
  return false;
     
}

bool MoveSix( Monster *M, int px , int py ,  point base[21][80], int mc , bool check,  Monster *Ori)
{
  int referx = px - M->x;
  int refery = py - M->y;

  if((referx == 0 && refery ==1) || (referx == 0 && refery ==-1))
    {
      return true;
    }

  
  if(referx != 0)
    {
      if(referx > 0)
	{
	  
	  if(base[(M->x)+1][M->y].value != ' ' && isSamePlace(Ori , mc , (M->x)+1 , (M->y)) == -1 && check == false)
	    {
	      M->x = (M->x)+1;
	      base[M->x][M->y].hardness = 0;
	    }
	  else if(isSamePlace(Ori , mc , (M->x)+1 , (M->y)) == -1 && check == true)
	    {
	      if(base[(M->x)+1][M->y].hardness/85 > 0)
		{
		  base[(M->x)+1][M->y].hardness -= 85;
		}
	      else
		{
		  M->x = (M->x)+1;
		  base[M->x][M->y].hardness = 0;
		}
	    }
	}
      else if(referx < 0)
	{
	  if(base[(M->x)-1][M->y].value != ' ' && isSamePlace(Ori , mc , (M->x)-1 , (M->y)) == -1 && check == false)
	    {
	      M->x = (M->x)-1;
	      base[M->x][M->y].hardness = 0;
	    }
	  else if(isSamePlace(Ori , mc , (M->x)-1 , (M->y)) == -1 && check == true)
	    {
	      if(base[(M->x)-1][M->y].hardness/85 > 0)
		{
		  base[(M->x)-1][M->y].hardness -= 85;
		}
	      else
		{
		  M->x = (M->x)-1;
		  base[M->x][M->y].hardness = 0;
		}
	    }

	}
    }
  else if(refery != 0 || (referx == (px - M->x) && referx != 0))
    {

      if(refery > 0)
	{
	  if(base[M->x][(M->y)+1].value != ' ' && isSamePlace(Ori , mc , (M->x) , (M->y)+1) == -1 && check == false)
	    {
	      M->y = (M->y) +1;
	      base[M->x][M->y].hardness = 0;
	    }
	  else if(isSamePlace(Ori , mc , (M->x) , (M->y)+1) == -1 && check == true)
	    {
	      if(base[M->x][(M->y)+1].hardness/85 > 0)
		{
		  base[M->x][(M->y)+1].hardness -=85;
		}
	      else
		{
		  M->y = (M->y)+1;
		  base[M->x][M->y].hardness = 0;
		}
	    }
	}
      else if(refery <0)
	{
	  if(base[M->x][(M->y)-1].value != ' ' && isSamePlace(Ori , mc , (M->x) , (M->y)-1) == -1 && check == false)
	    {
	      M->y = (M->y) -1;
	      base[M->x][M->y].hardness = 0;
	    }
	  else if(isSamePlace(Ori , mc , (M->x) , (M->y)-1) == -1 && check == true)
	    {
	      if(base[M->x][(M->y)-1].hardness/85 > 0)
		{
		  base[M->x][(M->y)-1].hardness -=85;
		}
	      else
		{
		  M->y = (M->y)-1;
		  base[M->x][M->y].hardness = 0;
		}
	    }
	}

    }
  else
    {
      return true;
    }

  return false;

}

bool Moverand( Monster *M , point base[21][80] , int mc , bool check , int px ,int py, Monster *Ori)
{
  int movex[8] = {-1,-1,-1,0,0,1,1,1};
  int movey[8] = {-1,0,1,-1,1,-1,0,1};
  int i = rand()%8;

  int  x = (M->x)+movex[i];
  int  y = (M->y)+movey[i];
  if(x > 19 || x < 1  || y >78 || y <1 )
    {
      return false;
    }
   
  if(check == false)
    {

      if(base[x][y].hardness == 0 && isSamePlace(Ori , mc , x, y) == -1)
	{
	  M->x = x;
	  M->y = y;
	}
    }
  else
    {
      if( isSamePlace(M , mc , x, y) == -1)
	{
	  if(base[x][y].hardness/85 > 0)
	    {
	      base[x][y].hardness -= 85;
	    }
	  else
	    {
	      M->x = x;
	      M->y = y;
	      base[M->x][M->y].hardness = 0;
	    }
	}
    }
   
  if(M->x == px && M->y == py)
    {
      return true;
    }

  return false;
}


void tempprint(WINDOW** temp)
{
  int i , j ;
  for(i = 0 ; i < 21 ; i++)
    {
      for(j = 0 ; j <80;j++)
	{
	  mvwprintw(*temp,i,j,"%c" , '*');
	}
    }
}



int main (int argc , char *argv[])
{
  int i,n;
   point Base[21][80];
  srand (time(NULL));
  int size = 0;
  int MonsterCount = 10;
   room *rooms;
  int playlocation[2];
  bool issave = false;
  bool isload = false;
   Monster *Monsters;
	

  rooms = ( room*)malloc(10*sizeof( room));

  char *home = getenv("HOME");
  char *dir = strcat(home , "/111.rlg327");
  //dir = strcat(dir, "/dungeon");

  n = argc;

  for( i = 0 ; i < n ; i++)
    {
      if(strcmp("--save" , argv[i])==0)
	{
	  issave =true;
	}
      else if(strcmp("--load" , argv[i])==0)
	{
	  isload = true;
	}
      if(strcmp("--n" , argv[i]) == 0)
	{
	  if(argv[i+1] != NULL)
	    {
	      MonsterCount = atoi(argv[i+1]);
	    }
	}
    }

  Monsters = ( Monster*)malloc((MonsterCount+1)*sizeof( Monster));
	
  if(isload)
    {
      loadFile(Base , rooms , &size , dir , playlocation );
    }
  else
    {
      generatemap(Base , &size , rooms , playlocation);	  
    }
		
  if(issave)
    {
      WriteFile(size , playlocation , Base , rooms , dir);
    }
		
  GMonster(rooms , Monsters , size ,Base , MonsterCount);
	       
  //PrintMonster(Monsters , MonsterCount, Base,playlocation[0],playlocation[1]);	   
  bool check = MonsterMove(Monsters , MonsterCount, Base , playlocation[0] , playlocation[1]);

  while(check)
    {
      generatemap(Base , &size , rooms , playlocation);
      GMonster(rooms , Monsters , size ,Base , MonsterCount);	   
      check = MonsterMove(Monsters , MonsterCount, Base , playlocation[0] , playlocation[1]);
    }
	       
  return 0;

}

